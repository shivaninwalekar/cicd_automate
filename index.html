<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>SNAKE</title>
<link href="https://fonts.googleapis.com/css2?family=Share+Tech+Mono&family=Orbitron:wght@400;700;900&display=swap" rel="stylesheet">
<style>
  :root {
    --bg: #0a0a0f;
    --panel: #0f0f1a;
    --border: #1a1a2e;
    --snake: #00ff9d;
    --snake-dark: #00c878;
    --food: #ff3e6c;
    --food-glow: rgba(255, 62, 108, 0.6);
    --accent: #00ff9d;
    --accent-glow: rgba(0, 255, 157, 0.4);
    --text: #e0e0f0;
    --dim: #555577;
    --grid: rgba(255,255,255,0.03);
  }

  * { margin: 0; padding: 0; box-sizing: border-box; }

  body {
    background: var(--bg);
    color: var(--text);
    font-family: 'Share Tech Mono', monospace;
    min-height: 100vh;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    overflow: hidden;
    position: relative;
  }

  body::before {
    content: '';
    position: fixed;
    inset: 0;
    background: 
      radial-gradient(ellipse at 20% 20%, rgba(0,255,157,0.05) 0%, transparent 50%),
      radial-gradient(ellipse at 80% 80%, rgba(255,62,108,0.05) 0%, transparent 50%);
    pointer-events: none;
  }

  /* Scanlines */
  body::after {
    content: '';
    position: fixed;
    inset: 0;
    background: repeating-linear-gradient(
      0deg,
      transparent,
      transparent 2px,
      rgba(0,0,0,0.08) 2px,
      rgba(0,0,0,0.08) 4px
    );
    pointer-events: none;
    z-index: 100;
  }

  .wrapper {
    display: flex;
    gap: 24px;
    align-items: flex-start;
    padding: 20px;
  }

  /* Title */
  .title-area {
    text-align: center;
    margin-bottom: 16px;
  }

  .title {
    font-family: 'Orbitron', monospace;
    font-weight: 900;
    font-size: 2.8rem;
    letter-spacing: 0.3em;
    color: var(--accent);
    text-shadow: 0 0 20px var(--accent-glow), 0 0 60px rgba(0,255,157,0.2);
    animation: flicker 8s infinite;
  }

  @keyframes flicker {
    0%, 94%, 96%, 100% { opacity: 1; }
    95% { opacity: 0.7; }
  }

  .subtitle {
    font-size: 0.65rem;
    color: var(--dim);
    letter-spacing: 0.4em;
    margin-top: 4px;
  }

  /* Game area */
  .game-column {
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 16px;
  }

  .canvas-wrapper {
    position: relative;
    border: 1px solid var(--accent);
    box-shadow: 
      0 0 0 1px rgba(0,255,157,0.1),
      0 0 30px rgba(0,255,157,0.15),
      inset 0 0 30px rgba(0,0,0,0.5);
    border-radius: 4px;
  }

  canvas {
    display: block;
    border-radius: 3px;
  }

  /* Overlay screens */
  .overlay {
    position: absolute;
    inset: 0;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    background: rgba(10, 10, 15, 0.92);
    border-radius: 3px;
    gap: 20px;
    transition: opacity 0.3s;
  }

  .overlay.hidden { opacity: 0; pointer-events: none; }

  .overlay-title {
    font-family: 'Orbitron', monospace;
    font-size: 1.8rem;
    font-weight: 900;
    color: var(--accent);
    text-shadow: 0 0 20px var(--accent-glow);
    letter-spacing: 0.2em;
  }

  .overlay-score {
    font-size: 1rem;
    color: var(--dim);
    letter-spacing: 0.2em;
  }

  .overlay-score span {
    color: var(--text);
    font-size: 1.4rem;
  }

  .btn {
    font-family: 'Orbitron', monospace;
    font-size: 0.75rem;
    font-weight: 700;
    letter-spacing: 0.25em;
    padding: 12px 32px;
    background: transparent;
    color: var(--accent);
    border: 1px solid var(--accent);
    cursor: pointer;
    border-radius: 2px;
    transition: all 0.2s;
    text-transform: uppercase;
  }

  .btn:hover {
    background: var(--accent);
    color: var(--bg);
    box-shadow: 0 0 20px var(--accent-glow);
  }

  /* Side panel */
  .side-panel {
    display: flex;
    flex-direction: column;
    gap: 16px;
    width: 160px;
    margin-top: 64px;
  }

  .panel-box {
    border: 1px solid var(--border);
    padding: 16px;
    background: var(--panel);
    border-radius: 4px;
    position: relative;
  }

  .panel-box::before {
    content: attr(data-label);
    position: absolute;
    top: -8px;
    left: 12px;
    background: var(--panel);
    padding: 0 6px;
    font-size: 0.55rem;
    letter-spacing: 0.3em;
    color: var(--dim);
    text-transform: uppercase;
  }

  .panel-value {
    font-family: 'Orbitron', monospace;
    font-size: 2rem;
    font-weight: 700;
    color: var(--accent);
    text-align: center;
    text-shadow: 0 0 10px var(--accent-glow);
  }

  .panel-value.food-color {
    color: var(--food);
    text-shadow: 0 0 10px var(--food-glow);
  }

  /* Level bar */
  .level-bar-bg {
    width: 100%;
    height: 4px;
    background: var(--border);
    border-radius: 2px;
    margin-top: 8px;
    overflow: hidden;
  }

  .level-bar-fill {
    height: 100%;
    background: var(--accent);
    border-radius: 2px;
    transition: width 0.3s;
    box-shadow: 0 0 6px var(--accent-glow);
  }

  /* Controls hint */
  .controls-hint {
    text-align: center;
    font-size: 0.6rem;
    color: var(--dim);
    letter-spacing: 0.15em;
    line-height: 1.8;
  }

  .key {
    display: inline-block;
    padding: 1px 6px;
    border: 1px solid var(--dim);
    border-radius: 2px;
    font-size: 0.55rem;
    color: var(--text);
  }

  /* Score pop animation */
  @keyframes scorePop {
    0% { transform: scale(1); }
    50% { transform: scale(1.3); color: #fff; }
    100% { transform: scale(1); }
  }

  .pop { animation: scorePop 0.3s ease; }

  /* Mobile controls */
  .mobile-controls {
    display: none;
    grid-template-areas: ". up ." "left . right" ". down .";
    grid-template-columns: repeat(3, 50px);
    gap: 4px;
    margin-top: 8px;
  }

  .mob-btn {
    width: 50px;
    height: 50px;
    background: var(--panel);
    border: 1px solid var(--border);
    color: var(--accent);
    font-size: 1.2rem;
    cursor: pointer;
    border-radius: 4px;
    display: flex;
    align-items: center;
    justify-content: center;
    transition: all 0.1s;
    user-select: none;
    -webkit-tap-highlight-color: transparent;
  }

  .mob-btn:active {
    background: var(--accent);
    color: var(--bg);
  }

  .mob-btn[data-dir="UP"] { grid-area: up; }
  .mob-btn[data-dir="LEFT"] { grid-area: left; }
  .mob-btn[data-dir="RIGHT"] { grid-area: right; }
  .mob-btn[data-dir="DOWN"] { grid-area: down; }

  @media (max-width: 600px) {
    .wrapper { flex-direction: column; align-items: center; gap: 12px; }
    .side-panel { flex-direction: row; width: auto; margin-top: 0; flex-wrap: wrap; justify-content: center; }
    .panel-box { min-width: 120px; }
    .mobile-controls { display: grid; }
    .title { font-size: 1.8rem; }
  }
</style>
</head>
<body>

<div class="game-column">
  <div class="title-area">
    <div class="title">SNAKE</div>
    <div class="subtitle">ARCADE EDITION</div>
  </div>

  <div class="wrapper">
    <div class="side-panel">
      <div class="panel-box" data-label="Score">
        <div class="panel-value" id="scoreDisplay">0</div>
      </div>
      <div class="panel-box" data-label="Best">
        <div class="panel-value" id="bestDisplay">0</div>
      </div>
      <div class="panel-box" data-label="Level">
        <div class="panel-value" id="levelDisplay">1</div>
        <div class="level-bar-bg">
          <div class="level-bar-fill" id="levelBar" style="width: 0%"></div>
        </div>
      </div>
      <div class="panel-box" data-label="Length">
        <div class="panel-value food-color" id="lengthDisplay">1</div>
      </div>
    </div>

    <div>
      <div class="canvas-wrapper">
        <canvas id="gameCanvas" width="420" height="420"></canvas>

        <!-- Start screen -->
        <div class="overlay" id="startScreen">
          <div class="overlay-title">READY?</div>
          <div class="overlay-score">USE ARROW KEYS OR WASD</div>
          <button class="btn" id="startBtn">START GAME</button>
        </div>

        <!-- Game over screen -->
        <div class="overlay hidden" id="gameOverScreen">
          <div class="overlay-title">GAME OVER</div>
          <div class="overlay-score">SCORE <span id="finalScore">0</span></div>
          <div class="overlay-score" id="newBestMsg" style="color: var(--accent); display:none;">✦ NEW BEST ✦</div>
          <button class="btn" id="restartBtn">PLAY AGAIN</button>
        </div>
      </div>

      <div class="mobile-controls">
        <button class="mob-btn" data-dir="UP">▲</button>
        <button class="mob-btn" data-dir="LEFT">◀</button>
        <button class="mob-btn" data-dir="RIGHT">▶</button>
        <button class="mob-btn" data-dir="DOWN">▼</button>
      </div>
    </div>

    <div class="side-panel">
      <div class="panel-box" data-label="Controls">
        <div class="controls-hint">
          <span class="key">W</span> <span class="key">↑</span> Up<br>
          <span class="key">S</span> <span class="key">↓</span> Down<br>
          <span class="key">A</span> <span class="key">←</span> Left<br>
          <span class="key">D</span> <span class="key">→</span> Right<br><br>
          <span class="key">P</span> Pause
        </div>
      </div>
      <div class="panel-box" data-label="Speed">
        <div class="panel-value" id="speedDisplay" style="font-size:1.2rem; color: var(--dim);">NORMAL</div>
      </div>
    </div>
  </div>
</div>

<script>
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');

const COLS = 21, ROWS = 21;
const CELL = canvas.width / COLS;
const COLORS = {
  bg: '#0a0a0f',
  grid: 'rgba(255,255,255,0.03)',
  snake: '#00ff9d',
  snakeDark: '#00c878',
  snakeHead: '#ffffff',
  food: '#ff3e6c',
  foodGlow: 'rgba(255,62,108,0.8)',
  accent: '#00ff9d',
};

// Game state
let snake, dir, nextDir, food, score, best, level, gameLoop, gameState, particles;
best = parseInt(localStorage.getItem('snakeBest') || '0');

const SPEED_TABLE = [140, 125, 110, 95, 80, 68, 58, 50, 43, 38];
const SPEED_LABELS = ['NORMAL','FAST','FAST','FASTER','FASTER','BLAZING','BLAZING','INSANE','INSANE','MAX'];

function init() {
  snake = [
    { x: 10, y: 10 },
    { x: 9,  y: 10 },
    { x: 8,  y: 10 },
  ];
  dir = { x: 1, y: 0 };
  nextDir = { x: 1, y: 0 };
  score = 0;
  level = 1;
  particles = [];
  placeFood();
  updateUI();
}

function placeFood() {
  let pos;
  do {
    pos = {
      x: Math.floor(Math.random() * COLS),
      y: Math.floor(Math.random() * ROWS)
    };
  } while (snake.some(s => s.x === pos.x && s.y === pos.y));
  food = pos;
  food.pulse = 0;
}

function getLevel() {
  return Math.min(10, Math.floor(score / 30) + 1);
}

function getSpeed() {
  return SPEED_TABLE[Math.min(level - 1, SPEED_TABLE.length - 1)];
}

function updateUI() {
  const scoreEl = document.getElementById('scoreDisplay');
  scoreEl.textContent = score;
  document.getElementById('bestDisplay').textContent = best;
  document.getElementById('levelDisplay').textContent = level;
  document.getElementById('lengthDisplay').textContent = snake.length;

  const scoreInLevel = (score % 30);
  document.getElementById('levelBar').style.width = (scoreInLevel / 30 * 100) + '%';
  document.getElementById('speedDisplay').textContent = SPEED_LABELS[Math.min(level - 1, SPEED_LABELS.length - 1)];
}

// Particles
function spawnParticles(x, y) {
  for (let i = 0; i < 12; i++) {
    const angle = (Math.PI * 2 / 12) * i + Math.random() * 0.3;
    particles.push({
      x: x * CELL + CELL/2,
      y: y * CELL + CELL/2,
      vx: Math.cos(angle) * (1.5 + Math.random() * 2.5),
      vy: Math.sin(angle) * (1.5 + Math.random() * 2.5),
      life: 1,
      size: 2 + Math.random() * 3,
    });
  }
}

function updateParticles() {
  for (let i = particles.length - 1; i >= 0; i--) {
    const p = particles[i];
    p.x += p.vx;
    p.y += p.vy;
    p.vx *= 0.92;
    p.vy *= 0.92;
    p.life -= 0.045;
    if (p.life <= 0) particles.splice(i, 1);
  }
}

function drawParticles() {
  particles.forEach(p => {
    ctx.save();
    ctx.globalAlpha = p.life;
    ctx.fillStyle = COLORS.food;
    ctx.shadowColor = COLORS.food;
    ctx.shadowBlur = 8;
    ctx.beginPath();
    ctx.arc(p.x, p.y, p.size * p.life, 0, Math.PI * 2);
    ctx.fill();
    ctx.restore();
  });
}

// Drawing
function drawGrid() {
  ctx.strokeStyle = COLORS.grid;
  ctx.lineWidth = 0.5;
  for (let i = 0; i <= COLS; i++) {
    ctx.beginPath();
    ctx.moveTo(i * CELL, 0);
    ctx.lineTo(i * CELL, canvas.height);
    ctx.stroke();
  }
  for (let i = 0; i <= ROWS; i++) {
    ctx.beginPath();
    ctx.moveTo(0, i * CELL);
    ctx.lineTo(canvas.width, i * CELL);
    ctx.stroke();
  }
}

function drawSnake() {
  snake.forEach((seg, i) => {
    const isHead = i === 0;
    const t = 1 - (i / snake.length) * 0.65;

    const x = seg.x * CELL + 1;
    const y = seg.y * CELL + 1;
    const s = CELL - 2;

    ctx.save();

    if (isHead) {
      ctx.shadowColor = COLORS.snake;
      ctx.shadowBlur = 15;
      ctx.fillStyle = '#fff';
    } else {
      ctx.shadowColor = COLORS.snake;
      ctx.shadowBlur = 8 * t;
      const g = ctx.createLinearGradient(x, y, x + s, y + s);
      g.addColorStop(0, `rgba(0, 255, 157, ${t})`);
      g.addColorStop(1, `rgba(0, 180, 110, ${t * 0.7})`);
      ctx.fillStyle = g;
    }

    const r = isHead ? 6 : 4;
    ctx.beginPath();
    ctx.roundRect(x, y, s, s, r);
    ctx.fill();

    // Head eyes
    if (isHead) {
      ctx.shadowBlur = 0;
      ctx.fillStyle = COLORS.bg;
      const ex = dir.x === 0 ? s * 0.3 : (dir.x > 0 ? s * 0.65 : s * 0.15);
      const ey1 = dir.y === 0 ? s * 0.25 : (dir.y > 0 ? s * 0.6 : s * 0.15);
      const ey2 = dir.y === 0 ? s * 0.65 : ey1;
      const ex2 = dir.x === 0 ? s * 0.65 : ex;
      ctx.beginPath(); ctx.arc(x + ex, y + ey1, 2.5, 0, Math.PI * 2); ctx.fill();
      ctx.beginPath(); ctx.arc(x + ex2, y + ey2, 2.5, 0, Math.PI * 2); ctx.fill();
      ctx.fillStyle = '#00ff9d';
      ctx.beginPath(); ctx.arc(x + ex + 0.8, y + ey1 - 0.8, 1, 0, Math.PI * 2); ctx.fill();
      ctx.beginPath(); ctx.arc(x + ex2 + 0.8, y + ey2 - 0.8, 1, 0, Math.PI * 2); ctx.fill();
    }

    ctx.restore();
  });
}

let foodPulse = 0;
function drawFood() {
  foodPulse = (foodPulse + 0.07) % (Math.PI * 2);
  const scale = 1 + Math.sin(foodPulse) * 0.12;
  const cx = food.x * CELL + CELL / 2;
  const cy = food.y * CELL + CELL / 2;
  const r = (CELL / 2 - 3) * scale;

  ctx.save();
  // Outer glow
  const glow = ctx.createRadialGradient(cx, cy, 0, cx, cy, r * 2);
  glow.addColorStop(0, 'rgba(255, 62, 108, 0.3)');
  glow.addColorStop(1, 'transparent');
  ctx.fillStyle = glow;
  ctx.beginPath();
  ctx.arc(cx, cy, r * 2, 0, Math.PI * 2);
  ctx.fill();

  // Main circle
  ctx.shadowColor = COLORS.food;
  ctx.shadowBlur = 20;
  const g = ctx.createRadialGradient(cx - r*0.3, cy - r*0.3, 0, cx, cy, r);
  g.addColorStop(0, '#ff8fa8');
  g.addColorStop(1, COLORS.food);
  ctx.fillStyle = g;
  ctx.beginPath();
  ctx.arc(cx, cy, r, 0, Math.PI * 2);
  ctx.fill();

  // Shine
  ctx.shadowBlur = 0;
  ctx.fillStyle = 'rgba(255,255,255,0.5)';
  ctx.beginPath();
  ctx.arc(cx - r * 0.3, cy - r * 0.3, r * 0.25, 0, Math.PI * 2);
  ctx.fill();
  ctx.restore();
}

function draw() {
  // Background
  ctx.fillStyle = COLORS.bg;
  ctx.fillRect(0, 0, canvas.width, canvas.height);

  drawGrid();
  drawParticles();
  drawFood();
  drawSnake();
}

// Game logic
function step() {
  dir = { ...nextDir };

  const head = { x: snake[0].x + dir.x, y: snake[0].y + dir.y };

  // Wall collision
  if (head.x < 0 || head.x >= COLS || head.y < 0 || head.y >= ROWS) {
    endGame(); return;
  }

  // Self collision
  if (snake.some(s => s.x === head.x && s.y === head.y)) {
    endGame(); return;
  }

  snake.unshift(head);

  // Eat food
  if (head.x === food.x && head.y === food.y) {
    score += 10;
    if (score > best) { best = score; localStorage.setItem('snakeBest', best); }
    level = getLevel();
    spawnParticles(food.x, food.y);
    placeFood();

    // Pop animation on score
    const el = document.getElementById('scoreDisplay');
    el.classList.remove('pop');
    void el.offsetWidth;
    el.classList.add('pop');

    // Restart loop with new speed
    clearInterval(gameLoop);
    gameLoop = setInterval(step, getSpeed());
  } else {
    snake.pop();
  }

  updateUI();
}

function startGame() {
  init();
  document.getElementById('startScreen').classList.add('hidden');
  document.getElementById('gameOverScreen').classList.add('hidden');
  gameState = 'playing';

  clearInterval(gameLoop);
  gameLoop = setInterval(() => {
    updateParticles();
    step();
    draw();
  }, getSpeed());
}

// Keep drawing while paused
let drawLoop;

function endGame() {
  clearInterval(gameLoop);
  gameState = 'over';
  document.getElementById('finalScore').textContent = score;
  document.getElementById('newBestMsg').style.display = score >= best && score > 0 ? 'block' : 'none';
  document.getElementById('gameOverScreen').classList.remove('hidden');
}

// Continuous draw for particles even when not stepping
function renderLoop() {
  if (gameState === 'playing') draw();
  requestAnimationFrame(renderLoop);
}

// Controls
const DIRS = {
  ArrowUp:    { x:  0, y: -1 }, w: { x:  0, y: -1 },
  ArrowDown:  { x:  0, y:  1 }, s: { x:  0, y:  1 },
  ArrowLeft:  { x: -1, y:  0 }, a: { x: -1, y:  0 },
  ArrowRight: { x:  1, y:  0 }, d: { x:  1, y:  0 },
};

document.addEventListener('keydown', e => {
  const d = DIRS[e.key] || DIRS[e.key.toLowerCase()];
  if (d) {
    e.preventDefault();
    if (gameState !== 'playing') return;
    // Prevent reversing
    if (d.x !== -dir.x || d.y !== -dir.y) nextDir = d;
  }
  if (e.key === 'p' || e.key === 'P') togglePause();
});

let paused = false;
function togglePause() {
  if (gameState !== 'playing' && !paused) return;
  if (!paused) {
    clearInterval(gameLoop);
    paused = true;
  } else {
    gameLoop = setInterval(() => { updateParticles(); step(); draw(); }, getSpeed());
    paused = false;
  }
}

// Mobile controls
document.querySelectorAll('.mob-btn').forEach(btn => {
  btn.addEventListener('click', () => {
    const map = { UP: {x:0,y:-1}, DOWN: {x:0,y:1}, LEFT: {x:-1,y:0}, RIGHT: {x:1,y:0} };
    const d = map[btn.dataset.dir];
    if (d && gameState === 'playing' && (d.x !== -dir.x || d.y !== -dir.y)) nextDir = d;
  });
});

// Swipe support
let touchStart = null;
canvas.addEventListener('touchstart', e => {
  touchStart = { x: e.touches[0].clientX, y: e.touches[0].clientY };
  e.preventDefault();
}, { passive: false });

canvas.addEventListener('touchend', e => {
  if (!touchStart) return;
  const dx = e.changedTouches[0].clientX - touchStart.x;
  const dy = e.changedTouches[0].clientY - touchStart.y;
  if (Math.abs(dx) > Math.abs(dy)) {
    const d = dx > 0 ? {x:1,y:0} : {x:-1,y:0};
    if (d.x !== -dir.x) nextDir = d;
  } else {
    const d = dy > 0 ? {x:0,y:1} : {x:0,y:-1};
    if (d.y !== -dir.y) nextDir = d;
  }
  touchStart = null;
  e.preventDefault();
}, { passive: false });

document.getElementById('startBtn').addEventListener('click', startGame);
document.getElementById('restartBtn').addEventListener('click', startGame);

// Initial render
document.getElementById('bestDisplay').textContent = best;
ctx.fillStyle = COLORS.bg;
ctx.fillRect(0, 0, canvas.width, canvas.height);
drawGrid();

renderLoop();
</script>
</body>
</html>

